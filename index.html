<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>6561 â€” triple-merge puzzle</title>
<style>
  :root{
    --bg:#faf8ef; --board:#bbada0; --empty:#cdc1b4; --text:#776e65; --accent:#8f7a66;
  }
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text); font:16px/1.2 "Clear Sans","Helvetica Neue",Arial,sans-serif;
    display:flex; justify-content:center; align-items:stretch;
  }
  .wrap{ width:min(94vw,560px); margin:24px auto; }
  header{display:flex; align-items:flex-end; justify-content:space-between; gap:12px; margin-bottom:16px;}
  h1{font-size:44px; line-height:1; margin:0; letter-spacing:1px;}
  .sub{color:var(--accent); font-size:13px; margin-top:6px}
  .badges{display:flex; gap:8px; align-items:center;}
  .badge{
    background:#bbada0; color:#fff; padding:8px 12px; border-radius:6px; text-align:center; min-width:84px;
  }
  .badge .label{font-size:11px; opacity:.85}
  .badge .value{font-size:18px; font-weight:700}
  .btn{
    background:#8f7a66; color:#fff; border:none; border-radius:6px; padding:10px 14px; font-weight:700; cursor:pointer;
  }
  .btn:active{transform:translateY(1px)}
  .grid{
    position:relative; aspect-ratio:1/1; background:var(--board); border-radius:12px; padding:14px;
    box-shadow:0 6px 0 #a19084 inset;
    display:grid; grid-template-columns:repeat(4,1fr); grid-template-rows:repeat(4,1fr); gap:14px;
  }
  /* Empty cells (for the board background) */
  .cell{
    background:var(--empty); border-radius:8px;
  }
  /* Tiles */
  .tile{
    position:absolute; width:calc((100% - 14px*3 - 14px*2)/4); /* calc accounts for gap & padding */
    height:calc((100% - 14px*3 - 14px*2)/4);
    border-radius:8px; display:flex; align-items:center; justify-content:center;
    font-weight:700; font-size:28px;
    left:14px; top:14px; will-change:transform;
    transition: transform 110ms ease-in, background-color 110ms ease-in;
    box-shadow:0 6px 0 rgba(0,0,0,.06);
  }
  .tile.new{animation:pop 120ms ease-out}
  .tile.merge{animation:bump 120ms ease-out}
  @keyframes pop{from{transform:scale(.6)} to{transform:scale(1)}}
  @keyframes bump{0%{transform:scale(1)}60%{transform:scale(1.08)}100%{transform:scale(1)}}

  /* Pastel palette for base-3 values */
  .v3   { background:#f5e6ff; color:#6a4c93;}
  .v9   { background:#e8f0ff; color:#26408b;}
  .v27  { background:#e6fff6; color:#1d6f5b;}
  .v81  { background:#fff4e6; color:#8a5d12;}
  .v243 { background:#ffe6ec; color:#8a2e4d;}
  .v729 { background:#eaf7ff; color:#1e4d6b;}
  .v2187{ background:#eefbe6; color:#2b6b1e;}
  .v6561{ background:#fff1e6; color:#7a3712; font-size:26px;}
  .v19683{ background:#f1e6ff; color:#4b268a;} /* just in case you go beyond */

  .overlay{
    position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center;
  }
  .card{
    background:#fff; width:min(92vw,520px); border-radius:14px; padding:16px 16px 10px; position:relative;
    box-shadow:0 18px 60px rgba(0,0,0,.18);
  }
  .card h2{margin:8px 0 6px}
  .card p{margin:6px 0 10px; color:#444}
  .close{position:absolute; right:8px; top:8px; border:none; background:#eee; border-radius:999px; width:32px; height:32px; font-weight:700; cursor:pointer}
  .toast{
    position:fixed; left:50%; transform:translateX(-50%); bottom:18px; background:#8f7a66; color:#fff; padding:10px 14px; border-radius:999px;
    box-shadow:0 6px 20px rgba(0,0,0,.15); display:none;
  }
  .toast.show{display:block; animation:fadeout 1600ms 1200ms forwards}
  @keyframes fadeout{to{opacity:0; transform:translateX(-50%) translateY(8px)}}
  @media (max-width:380px){
    h1{font-size:34px}
    .tile{font-size:24px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>6561</h1>
        <div class="sub">Merge matching tiles â€” they <strong>triple</strong>. Reach <strong>6561</strong> to win!</div>
      </div>
      <div class="badges">
        <div class="badge" id="scoreBox"><div class="label">SCORE</div><div class="value" id="score">0</div></div>
        <div class="badge" id="bestBox"><div class="label">BEST</div><div class="value" id="best">0</div></div>
        <button class="btn" id="newGame">New Game</button>
      </div>
    </header>

    <div class="grid" id="grid" aria-label="game board">
      <!-- 16 background cells -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- tiles are absolutely positioned on top -->
    </div>

    <div id="toast" class="toast">You reached 6561 â€” you win! ðŸŽ‰</div>
  </div>

  <!-- Instructions overlay -->
  <div class="overlay" id="overlay">
    <div class="card">
      <button class="close" id="close">&times;</button>
      <h2>How to play</h2>
      <p>Use your <strong>arrow keys</strong> (or swipe) to slide tiles. When two tiles with the same number touch, they <strong>merge into one</strong> and <strong>triple</strong> in value.</p>
      <p>New tiles spawn as <strong>3</strong> (sometimes <strong>9</strong>). Get to <strong>6561</strong> to win. Good luck!</p>
      <button class="btn" id="letsGo">Letâ€™s play</button>
    </div>
  </div>

<script>
/* === Config for 6561 (base-3 variant) === */
const SIZE = 4;                         // 4x4 grid
const WIN_TILE = 6561;                  // 3^8
const MERGE_MULTIPLIER = 3;             // equal tiles triple on merge
const SPAWN_VALUES = [3,3,3,3,3,3,3,3,3,9]; // 90% 3, 10% 9
const ANIM_MS = 120;

/* === State === */
let grid = []; // 2D array of numbers or 0
let score = 0;
let best = Number(localStorage.getItem('best-6561') || 0);
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const bestEl  = document.getElementById('best');
bestEl.textContent = best;

/* Utility */
const posToXY = (r,c) => {
  // returns pixel transform for a tile at row r, col c
  const pad = 14; // container padding
  const gap = 14;
  const cellSize = (gridEl.clientWidth - pad*2 - gap*3) / SIZE;
  const x = pad + (cellSize + gap) * c;
  const y = pad + (cellSize + gap) * r;
  return `translate(${x}px, ${y}px)`;
};
const valueClass = (v) => `v${v}`;

/* Tile DOM map: id by "r-c" */
const tileMap = new Map();

function reset(){
  grid = Array.from({length:SIZE},()=>Array(SIZE).fill(0));
  score = 0; updateScore(0);
  // clear tiles
  tileMap.forEach(el => el.remove());
  tileMap.clear();
  spawn(); spawn();
  layoutAll(); // position after spawn
}

function randomEmpty(){
  const empties = [];
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!grid[r][c]) empties.push([r,c]);
  if(!empties.length) return null;
  return empties[Math.floor(Math.random()*empties.length)];
}

function spawn(){
  const spot = randomEmpty();
  if(!spot) return false;
  const val = SPAWN_VALUES[Math.floor(Math.random()*SPAWN_VALUES.length)];
  const [r,c] = spot; grid[r][c] = val;
  const id = `${r}-${c}-${Math.random().toString(36).slice(2)}`;
  const el = document.createElement('div');
  el.className = `tile new ${valueClass(val)}`;
  el.textContent = val;
  el.dataset.r = r; el.dataset.c = c; el.dataset.val = val; el.dataset.id = id;
  tileMap.set(id, el);
  gridEl.appendChild(el);
  requestAnimationFrame(()=>{ el.style.transform = posToXY(r,c); });
  return true;
}

function updateScore(delta){
  score += delta;
  scoreEl.textContent = score;
  if(score > best){ best = score; bestEl.textContent = best; localStorage.setItem('best-6561',best); }
}

function layoutAll(){
  // Ensure every tile's transform matches its logical r,c (resolve overlaps by z-index)
  // Rebuild mapping because merges may have changed positions
  // First, clean up removed nodes
  [...tileMap.entries()].forEach(([id, el])=>{
    if(!el.isConnected) tileMap.delete(id);
  });
  // Then position
  [...tileMap.values()].forEach(el=>{
    const r = +el.dataset.r, c = +el.dataset.c;
    el.style.transform = posToXY(r,c);
  });
}

function slide(dir){
  // dir: 'left','right','up','down'
  const drc = {
    left:{r:0,c:-1, loopR:[0,1,2,3], loopC:[0,1,2,3]},
    right:{r:0,c:1, loopR:[0,1,2,3], loopC:[3,2,1,0]},
    up:{r:-1,c:0, loopR:[0,1,2,3], loopC:[0,1,2,3]},
    down:{r:1,c:0, loopR:[3,2,1,0], loopC:[0,1,2,3]},
  }[dir];
  if(!drc) return;

  let moved = false;
  const mergedThisMove = Array.from({length:SIZE},()=>Array(SIZE).fill(false));

  const sequence = [];
  for(const r of drc.loopR){
    for(const c of drc.loopC){
      if(!grid[r][c]) continue;
      let nr=r, nc=c;
      while(true){
        const rr = nr + drc.r, cc = nc + drc.c;
        if(rr<0||rr>=SIZE||cc<0||cc>=SIZE) break;
        if(grid[rr][cc]===0){ nr=rr; nc=cc; continue; }
        if(grid[rr][cc]===grid[r][c] && !mergedThisMove[rr][cc]){
          // merge target
          nr=rr; nc=cc;
        }
        break;
      }
      if(nr===r && nc===c) continue;
      moved = true;
      sequence.push({from:[r,c], to:[nr,nc]});
      // perform logical move later to avoid chain issues
    }
  }

  // Apply moves/merges
  sequence.forEach(({from,to})=>{
    const [r,c]=from, [nr,nc]=to;
    if(grid[nr][nc]===0){
      // simple move
      grid[nr][nc] = grid[r][c];
      grid[r][c] = 0;
      moveTileDOM(r,c,nr,nc);
    }else if(grid[nr][nc]===grid[r][c] && !mergedThisMove[nr][nc]){
      // merge
      const newVal = grid[r][c] * MERGE_MULTIPLIER;
      grid[nr][nc] = newVal;
      grid[r][c] = 0;
      mergedThisMove[nr][nc] = true;
      mergeTileDOM(r,c,nr,nc,newVal);
      updateScore(newVal); // standard scoring: add the created tile
      if(newVal === WIN_TILE){ celebrate(); }
    }
  });

  if(moved){
    setTimeout(()=>{
      spawn();
      layoutAll();
      if(isGameOver()) showGameOver();
    }, ANIM_MS);
  }
}

function moveTileDOM(r,c,nr,nc){
  // find a DOM tile at r,c (the one with matching coords)
  const el = [...tileMap.values()].find(t => +t.dataset.r===r && +t.dataset.c===c);
  if(!el) return;
  el.dataset.r = nr; el.dataset.c = nc;
  el.style.transform = posToXY(nr,nc);
}

function mergeTileDOM(r,c,nr,nc,newVal){
  // two tiles occupy r,c and nr,nc; remove the moving one, update target
  // moving node:
  const mover = [...tileMap.values()].find(t => +t.dataset.r===r && +t.dataset.c===c);
  const target = [...tileMap.values()].find(t => +t.dataset.r===nr && +t.dataset.c===nc);
  if(mover){
    // animate mover onto target then remove
    mover.dataset.r = nr; mover.dataset.c = nc;
    mover.style.transform = posToXY(nr,nc);
    setTimeout(()=>{ mover.remove(); tileMap.delete(mover.dataset.id); }, ANIM_MS);
  }
  if(target){
    target.classList.add('merge');
    setTimeout(()=>target.classList.remove('merge'), ANIM_MS);
    // update class & text
    target.className = `tile ${valueClass(newVal)}`;
    target.textContent = newVal;
    target.dataset.val = newVal;
  }
}

function isGameOver(){
  // no empties and no merges available
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
    if(grid[r][c]===0) return false;
    const v=grid[r][c];
    if(r+1<SIZE && grid[r+1][c]===v) return false;
    if(c+1<SIZE && grid[r][c+1]===v) return false;
  }
  return true;
}

/* UI: win + game over */
function celebrate(){
  const toast = document.getElementById('toast');
  toast.classList.add('show');
  setTimeout(()=>toast.classList.remove('show'), 2600);
}

function showGameOver(){
  const overlay = document.createElement('div');
  overlay.className = 'overlay';
  overlay.innerHTML = `
    <div class="card" role="dialog" aria-label="Game over">
      <h2>Game over</h2>
      <p>Your score: <strong>${score}</strong></p>
      <button class="btn" id="again">Play again</button>
    </div>`;
  document.body.appendChild(overlay);
  overlay.querySelector('#again').addEventListener('click',()=>{
    overlay.remove(); reset();
  });
}

/* Inputs */
window.addEventListener('resize', layoutAll);
document.addEventListener('keydown', e=>{
  const k = e.key;
  if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(k)){
    e.preventDefault();
    slide(
      k==='ArrowLeft'?'left':
      k==='ArrowRight'?'right':
      k==='ArrowUp'?'up':'down'
    );
  }
});

/* Touch (swipe) */
let touchStart=null;
gridEl.addEventListener('touchstart', e=>{
  const t = e.changedTouches[0];
  touchStart = {x:t.clientX, y:t.clientY, time:Date.now()};
},{passive:true});
gridEl.addEventListener('touchend', e=>{
  if(!touchStart) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStart.x;
  const dy = t.clientY - touchStart.y;
  const adx = Math.abs(dx), ady = Math.abs(dy);
  const dt = Date.now() - touchStart.time;
  if(Math.max(adx,ady) > 24 && dt < 800){
    if(adx>ady) slide(dx>0?'right':'left');
    else slide(dy>0?'down':'up');
  }
  touchStart=null;
});

/* Buttons + overlay */
document.getElementById('newGame').addEventListener('click', reset);
document.getElementById('letsGo').addEventListener('click', ()=>document.getElementById('overlay').style.display='none');
document.getElementById('close').addEventListener('click', ()=>document.getElementById('overlay').style.display='none');

/* Init */
reset();
</script>
</body>
</html>
