<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>6561 ‚Äî 2 Players</title>
<style>
  :root{
    --bg:#ffeaf1; --board:#f3c2d1; --empty:#f8d7e3; --text:#7a2a4a; --accent:#b14172;
    --gap:14px; --pad:16px; --cell:100px; --gridW:360px; --anim:140ms;
  }

  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font:16px/1.2 "Clear Sans","Helvetica Neue",Arial,sans-serif;
    display:flex; justify-content:center; align-items:stretch;
    -webkit-tap-highlight-color: transparent;
  }
  .wrap{ width:min(98vw,1080px); margin:22px auto; }

  .modebar{display:flex; gap:8px; margin-bottom:12px; flex-wrap:wrap; align-items:center;}
  .tab{
    border:none; border-radius:999px; padding:8px 14px; font-weight:800; cursor:pointer;
    background:#ffd1e0; color:#7a2a4a; text-decoration:none;
    box-shadow:0 3px 10px rgba(255,179,201,.28);
  }
  .tab.active{ background:#b14172; color:#fff }

  header{display:flex; align-items:flex-end; justify-content:space-between; gap:12px; margin-bottom:12px;}
  h1{font-size:40px; line-height:1; margin:0}
  .sub{color:#a53d6b; font-size:13px; margin-top:6px}

  .boards{display:grid; grid-template-columns:1fr 1fr; gap:18px;}
  @media (max-width:900px){ .boards{grid-template-columns:1fr;} }

  .phead{display:flex; align-items:flex-end; justify-content:space-between; gap:10px; margin-bottom:8px;}
  .pname{ font-size:22px; font-weight:800; }
  .badge{ background:#d88aa7; color:#fff; padding:6px 10px; border-radius:8px; min-width:80px; text-align:center; }
  .badge .label{font-size:10px; opacity:.9}
  .badge .value{font-size:16px; font-weight:700}

  .powers{display:flex; gap:8px; margin:8px 0 12px; flex-wrap:wrap}
  .power{ background:#ffb3c9; border:none; border-radius:999px; padding:7px 12px; font-weight:700; cursor:pointer; box-shadow:0 3px 10px rgba(255,179,201,.28); }
  .power[disabled]{opacity:.45; cursor:not-allowed}
  .power.active{outline:3px solid #b14172; outline-offset:2px}

  .board{ position:relative; background:var(--board); border-radius:16px; padding:var(--pad); box-shadow:0 8px 0 rgba(0,0,0,.06) inset; }
  .grid{ position:relative; width:var(--gridW); height:var(--gridW);
         display:grid; grid-template-columns:repeat(3,var(--cell)); grid-template-rows:repeat(3,var(--cell)); gap:var(--gap); margin:0 auto;}
  .cell{ background:var(--empty); border-radius:12px; }
  .layer{ position:absolute; width:var(--gridW); height:var(--gridW); pointer-events:none; }

  .tile{ position:absolute; width:var(--cell); height:var(--cell); border-radius:12px;
    display:flex; align-items:center; justify-content:center; font-weight:800; font-size:28px;
    will-change:transform;
    transition:transform var(--anim) ease, background-color var(--anim) ease, color var(--anim) ease;
    box-shadow:0 10px 24px rgba(0,0,0,.08); user-select:none; pointer-events:auto;}
  .tile.new{animation:pop 140ms ease-out}
  .tile.merge{animation:bump 140ms ease-out}
  @keyframes pop{from{transform:scale(.6)} to{transform:scale(1)}}
  @keyframes bump{0%{transform:scale(1)}60%{transform:scale(1.08)}100%{transform:scale(1)}}

  .v3{background:#ffdce7;color:#7a2a4a;}
  .v9{background:#ffc7d9;color:#6f2041;}
  .v27{background:#ffadc7;color:#691c3c;}
  .v81{background:#ff94b7;color:#631837;}
  .v243{background:#ff7aa6;color:#5b1431;}
  .v729{background:#000;color:#fff;font-size:26px;}

  .btn{ background:#b14172; color:#fff; border:none; border-radius:10px; padding:9px 12px; font-weight:700; cursor:pointer; box-shadow:0 4px 14px rgba(177,65,114,.22); }
  .btn:active{transform:translateY(1px)}

  .overlay{ position:fixed; inset:0; background:rgba(0,0,0,.38); display:flex; align-items:center; justify-content:center; z-index:5; }
  .card{ background:#fff; width:min(92vw,560px); border-radius:16px; padding:16px; position:relative; box-shadow:0 24px 80px rgba(0,0,0,.22);}
  .card h2{margin:8px 0}
  .card p{margin:6px 0 10px; color:#444}
  .close{position:absolute; right:10px; top:10px; border:none; background:#eee; border-radius:999px; width:34px; height:34px; font-weight:700; cursor:pointer}

  /* Legends */
  .legend{font-size:12px; color:#7a2a4a; opacity:.9; margin-top:8px}
  .legend kbd{background:#ffd1e0; border-radius:6px; padding:2px 6px; font-weight:800; font-family:inherit}

  /* Countdown overlay */
  #countdown{ position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:6; }
  #countdown .bubble{
    width:170px; height:170px; border-radius:999px; background:#fff; display:flex; align-items:center; justify-content:center;
    font-size:64px; font-weight:900; color:#b14172; box-shadow:0 24px 80px rgba(0,0,0,.25);
    animation:pop 240ms ease-out;
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="modebar">
      <a class="tab" href="index.html">1 Player</a>
      <a class="tab active" href="multi.html">2 Players</a>
    </div>

    <header>
      <div>
        <h1>6561 ‚Äî Versus</h1>
        <div class="sub">Two boards, 3√ó3 each. First to <strong>729</strong> wins! P1: Arrows ¬∑ P2: WASD. One power-up each.</div>
      </div>
      <button class="btn" id="playAgain">Play Again</button>
    </header>

    <div class="boards">
      <!-- Player 1 -->
      <section id="p1">
        <div class="phead">
          <div class="pname">Player 1</div>
          <div class="badge"><div class="label">SCORE</div><div class="value" id="p1-score">0</div></div>
        </div>
        <div class="powers">
          <button class="power" id="p1-undo">‚Ü©Ô∏é Undo (1)</button>
          <button class="power" id="p1-shuffle">üîÄ Shuffle (1)</button>
          <button class="power" id="p1-hammer">ü™ì Hammer (1)</button>
        </div>
        <div class="board">
          <div class="grid" id="p1-grid">
            <div class="cell"></div><div class="cell"></div><div class="cell"></div>
            <div class="cell"></div><div class="cell"></div><div class="cell"></div>
            <div class="cell"></div><div class="cell"></div><div class="cell"></div>
          </div>
          <div class="layer" id="p1-layer"></div>
        </div>
        <div class="legend">Move with <kbd>‚Üë</kbd><kbd>‚Üì</kbd><kbd>‚Üê</kbd><kbd>‚Üí</kbd> ¬∑ Use power-up buttons above</div>
      </section>

      <!-- Player 2 -->
      <section id="p2">
        <div class="phead">
          <div class="pname">Player 2</div>
          <div class="badge"><div class="label">SCORE</div><div class="value" id="p2-score">0</div></div>
        </div>
        <div class="powers">
          <button class="power" id="p2-undo">‚Ü©Ô∏é Undo (1)</button>
          <button class="power" id="p2-shuffle">üîÄ Shuffle (1)</button>
          <button class="power" id="p2-hammer">ü™ì Hammer (1)</button>
        </div>
        <div class="board">
          <div class="grid" id="p2-grid">
            <div class="cell"></div><div class="cell"></div><div class="cell"></div>
            <div class="cell"></div><div class="cell"></div><div class="cell"></div>
            <div class="cell"></div><div class="cell"></div><div class="cell"></div>
          </div>
          <div class="layer" id="p2-layer"></div>
        </div>
        <div class="legend">Move with <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> ¬∑ Use power-up buttons above</div>
      </section>
    </div>
  </div>

  <!-- Instructions -->
  <div class="overlay" id="overlay">
    <div class="card">
      <button class="close" id="intro-close">&times;</button>
      <h2>How to play (2 Players)</h2>
      <p>Each player has a 3√ó3 board. Combine matching tiles to triple them.</p>
      <p>First to make <code>729</code> wins.</p>
      <ul style="margin:8px 0 10px; padding-left:18px;">
        <li><strong>Player 1:</strong> Arrow keys</li>
        <li><strong>Player 2:</strong> W A S D</li>
      </ul>
      <p>Each player gets <strong>one use</strong> of Undo, Shuffle and Hammer (tap a tile to delete).</p>
      <button class="btn" id="intro-play">Let‚Äôs play</button>
    </div>
  </div>

  <!-- Countdown -->
  <div id="countdown">
    <div class="bubble" id="countNum">3</div>
  </div>

  <!-- Win card -->
  <div class="overlay" id="win-layer" style="display:none">
    <div class="card">
      <button class="close" id="win-close">&times;</button>
      <h2 id="win-title">Player wins! üéâ</h2>
      <p id="win-desc">Create 729 before your opponent to win!</p>
      <button class="btn" id="win-again">Play Again</button>
    </div>
  </div>

<script>
/* ===== Shared config ===== */
const SIZE=3, WIN_TILE=729, MERGE=3;
const SPAWN=[3,3,3,3,3,3,3,3,3,9]; // 90% 3, 10% 9
const ANIM=150, LOCK=155;

/* Match-level input lock (disabled until countdown ends) */
let matchLocked = true;

const uid=()=>Math.random().toString(36).slice(2);
const valClass=v=>`v${v}`;
const key=(r,c)=>`${r},${c}`;

/* ===== Game class (per player) ===== */
class TriGame{
  constructor(rootId,label){
    this.label=label;                    // 'P1' or 'P2'
    this.root=document.getElementById(rootId);
    this.gridEl=this.root.querySelector('.grid');
    this.layerEl=this.root.querySelector('.layer');
    this.scoreEl=document.getElementById(`${label.toLowerCase()}-score`);
    this.undoBtn=document.getElementById(`${label.toLowerCase()}-undo`);
    this.shuffleBtn=document.getElementById(`${label.toLowerCase()}-shuffle`);
    this.hammerBtn=document.getElementById(`${label.toLowerCase()}-hammer`);
    this.boardEl=this.root.querySelector('.board');  // search inside panel
    if(!this.boardEl){ console.error(`[${this.label}] board not found`); return; }

    this.pad=16; this.gap=14; this.cell=100;
    this.geom={pos:[]};
    this.tiles=new Map();      // id ‚Üí {r,c,val,el}
    this.tilesByCell=new Map();// "r,c" ‚Üí id
    this.history=[];
    this.score=0; this.locked=false;
    this.powers={undo:1, shuffle:1, hammer:1, hammerActive:false};

    this.bindPowers();
    this.computeGeom();
    new ResizeObserver(()=>{ this.computeGeom(); this.layoutAll(); }).observe(this.boardEl);
    this.reset();
    this.setEnabled(!matchLocked); // reflect match lock on UI
  }

  computeGeom(){
    const st=getComputedStyle(document.documentElement);
    const pad=parseInt(st.getPropertyValue('--pad'))||16;
    const gap=parseInt(st.getPropertyValue('--gap'))||14;
    const bw=this.boardEl.clientWidth, inner=bw-pad*2;
    const cell=Math.floor((inner-gap*(SIZE-1))/SIZE);
    const gridW = cell*SIZE + gap*(SIZE-1);
    const off = Math.floor((inner-gridW)/2);

    [this.gridEl,this.layerEl].forEach(el=>{
      el.style.width = gridW+'px';
      el.style.height= gridW+'px';
      el.style.left  = pad+off+'px';
      el.style.top   = pad+off+'px';
    });

    const pos = Array.from({length:SIZE},(_,r)=>Array.from({length:SIZE},(_,c)=>({
      x: Math.round((cell+gap)*c), y: Math.round((cell+gap)*r)
    })));

    this.pad=pad; this.gap=gap; this.cell=cell; this.geom={pos};
  }

  /* ---- Enable/disable inputs & buttons for match lock ---- */
  setEnabled(on){
    const disable = (btn, d) => { btn.disabled = d; btn.classList.toggle('active', !d && btn.classList.contains('active')); };
    disable(this.undoBtn, !on || this.powers.undo<=0);
    disable(this.shuffleBtn, !on || this.powers.shuffle<=0);
    disable(this.hammerBtn, !on || this.powers.hammer<=0);
  }

  /* ---- Power-ups ---- */
  bindPowers(){
    const refresh=()=>this.updatePowersUI();

    this.undoBtn.addEventListener('click',()=>{
      if(matchLocked || this.powers.undo<=0 || this.locked) return;
      if(this.restoreFromHistory()){
        this.powers.undo--; refresh(); this.setEnabled(true);
      }
    });

    this.shuffleBtn.addEventListener('click',()=>{
      if(matchLocked || this.powers.shuffle<=0 || this.locked) return;
      this.pushHistory();
      const vals=[...this.tiles.values()].map(t=>t.val);
      // clear
      this.layerEl.innerHTML=''; this.tiles.clear(); this.tilesByCell.clear();
      this.grid = Array.from({length:SIZE},()=>Array(SIZE).fill(0));
      // re-place randomly
      for(const v of vals.sort(()=>Math.random()-0.5)){
        const s=this.randomEmpty(); if(!s) break;
        const [r,c]=s; this.grid[r][c]=v; this.createTile(r,c,v,true);
      }
      this.layoutAll();
      this.powers.shuffle--; refresh(); this.setEnabled(true);
    });

    this.hammerBtn.addEventListener('click',()=>{
      if(matchLocked || this.powers.hammer<=0) return;
      this.powers.hammerActive = !this.powers.hammerActive;
      refresh();
    });
  }

  updatePowersUI(){
    const set=(btn,label,count,active=false)=>{
      btn.textContent = `${label} (${count})`;
      btn.disabled = matchLocked || count<=0;
      btn.classList.toggle('active', active && !matchLocked);
    };
    set(this.undoBtn,'‚Ü©Ô∏é Undo',this.powers.undo);
    set(this.shuffleBtn,'üîÄ Shuffle',this.powers.shuffle);
    set(this.hammerBtn,'ü™ì Hammer',this.powers.hammer,this.powers.hammerActive);
  }

  /* ---- Core helpers ---- */
  randomEmpty(){
    const e=[]; for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!this.grid[r][c]) e.push([r,c]);
    return e.length? e[(Math.random()*e.length)|0] : null;
  }
  createTile(r,c,val,noPop=false){
    const id=uid();
    const el=document.createElement('div');
    el.className=`tile ${noPop?'':'new'} ${valClass(val)}`;
    el.textContent=val;
    const {x,y}=this.geom.pos[r][c];
    el.style.transform=`translate3d(${x}px,${y}px,0)`;
    this.layerEl.appendChild(el);

    const t={id,r,c,val,el};
    this.tiles.set(id,t);
    this.tilesByCell.set(key(r,c), id);

    // Hammer: delete on click
    el.addEventListener('click', ()=>{
      if(matchLocked || this.powers.hammerActive===false || this.powers.hammer<=0 || this.locked) return;
      this.pushHistory();
      this.grid[r][c]=0; this.deleteAt(r,c);
      this.powers.hammerActive=false; this.powers.hammer--; this.updatePowersUI(); this.setEnabled(true);
      setTimeout(()=>{ this.spawn(); if(this.isWin()) announceWinner(this.label); }, ANIM);
    });
  }
  deleteAt(r,c){
    const id=this.tilesByCell.get(key(r,c)); if(!id) return;
    this.tilesByCell.delete(key(r,c));
    const t=this.tiles.get(id);
    if(t){ t.el.remove(); this.tiles.delete(id); }
  }
  layoutAll(){
    requestAnimationFrame(()=>{
      for(const t of this.tiles.values()){
        const {x,y}=this.geom.pos[t.r][t.c];
        t.el.style.transform=`translate3d(${x}px,${y}px,0)`;
      }
    });
  }
  setTileValue(t,val){
    t.val=val;
    t.el.className=`tile ${valClass(val)}`;
    t.el.textContent=val;
  }
  moveTileTo(t,nr,nc){
    this.tilesByCell.delete(key(t.r,t.c));
    t.r=nr; t.c=nc;
    this.tilesByCell.set(key(nr,nc), t.id);
    const {x,y}=this.geom.pos[nr][nc];
    t.el.style.transform=`translate3d(${x}px,${y}px,0)`;
  }

  /* ---- History (Undo) ---- */
  pushHistory(){
    this.history.push({
      grid: this.grid.map(r=>r.slice()),
      score: this.score,
      tiles: [...this.tiles.values()].map(t=>({r:t.r,c:t.c,val:t.val}))
    });
    if(this.history.length>20) this.history.shift();
  }
  restoreFromHistory(){
    const s=this.history.pop(); if(!s) return false;
    this.grid = s.grid.map(r=>r.slice());
    this.score = s.score; this.scoreEl.textContent=this.score;
    this.layerEl.innerHTML=''; this.tiles.clear(); this.tilesByCell.clear();
    for(const d of s.tiles){ this.createTile(d.r,d.c,d.val,true); }
    this.layoutAll();
    return true;
  }

  /* ---- Public API ---- */
  reset(){
    this.locked=false;
    this.grid = Array.from({length:SIZE},()=>Array(SIZE).fill(0));
    this.score=0; this.scoreEl.textContent=0;
    this.layerEl.innerHTML=''; this.tiles.clear(); this.tilesByCell.clear(); this.history=[];
    this.powers={undo:1, shuffle:1, hammer:1, hammerActive:false}; this.updatePowersUI();
    this.spawn(); this.spawn(); this.layoutAll();
  }

  spawn(){
    const s=this.randomEmpty(); if(!s) return false;
    const [r,c]=s;
    const v=SPAWN[(Math.random()*SPAWN.length)|0];
    this.grid[r][c]=v; this.createTile(r,c,v,false);
    return true;
  }

  slide(dir){
    if(matchLocked || this.locked) return;
    this.locked = true; setTimeout(()=>{ this.locked=false; }, LOCK);

    const drc = {
      left: {dr:0, dc:-1, rows:[0,1,2], cols:[0,1,2]},
      right:{dr:0, dc:1,  rows:[0,1,2], cols:[2,1,0]},
      up:   {dr:-1,dc:0,  rows:[0,1,2], cols:[0,1,2]},
      down: {dr:1, dc:0,  rows:[2,1,0], cols:[0,1,2]},
    }[dir];
    if(!drc){ this.locked=false; return; }

    this.pushHistory();

    let moved=false;
    const merged = Array.from({length:SIZE},()=>Array(SIZE).fill(false));

    for(const r of drc.rows){
      for(const c of drc.cols){
        const v=this.grid[r][c]; if(!v) continue;
        let nr=r, nc=c;
        while(true){
          const rr=nr+drc.dr, cc=nc+drc.dc;
          if(rr<0||rr>=SIZE||cc<0||cc>=SIZE) break;
          if(this.grid[rr][cc]===0){ nr=rr; nc=cc; continue; }
          if(this.grid[rr][cc]===v && !merged[rr][cc]){ nr=rr; nc=cc; }
          break;
        }
        if(nr===r && nc===c) continue;
        moved=true;

        const moverId=this.tilesByCell.get(key(r,c));
        const mover=this.tiles.get(moverId);

        if(this.grid[nr][nc]===0){
          this.grid[nr][nc]=v; this.grid[r][c]=0;
          this.moveTileTo(mover,nr,nc);
        }else if(this.grid[nr][nc]===v && !merged[nr][nc]){
          const newVal = v*MERGE;
          this.grid[nr][nc]=newVal; this.grid[r][c]=0; merged[nr][nc]=true;

          const targetId=this.tilesByCell.get(key(nr,nc));
          const target=this.tiles.get(targetId);

          this.moveTileTo(mover,nr,nc);
          setTimeout(()=>{
            if(this.tiles.has(mover.id)){ mover.el.remove(); this.tiles.delete(mover.id); }
            this.tilesByCell.set(key(nr,nc), target.id);
            target.el.classList.add('merge');
            setTimeout(()=>target.el.classList.remove('merge'), ANIM);
            this.setTileValue(target,newVal);
          }, ANIM*0.9);

          // simple scoring: add created value
          this.score = (this.score||0) + newVal;
          this.scoreEl.textContent = this.score;
        }
      }
    }

    if(moved){
      setTimeout(()=>{
        this.spawn();
        this.layoutAll();
        if(this.isWin()) announceWinner(this.label);
      }, ANIM);
    }else{
      this.history.pop();
    }
  }

  isWin(){
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
      if(this.grid[r][c]===WIN_TILE) return true;
    }
    return false;
  }
}

/* ===== Create the two games ===== */
const g1 = new TriGame('p1','P1');
const g2 = new TriGame('p2','P2');

/* ===== Keyboard controls ===== */
document.addEventListener('keydown', e=>{
  if(matchLocked) return; // blocked during countdown/intro
  const k=e.key;
  if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(k)){
    e.preventDefault();
    g1.slide(k==='ArrowLeft'?'left':k==='ArrowRight'?'right':k==='ArrowUp'?'up':'down');
  }else if(['w','a','s','d','W','A','S','D'].includes(k)){
    e.preventDefault();
    const m={w:'up',W:'up',a:'left',A:'left',s:'down',S:'down',d:'right',D:'right'}[k];
    g2.slide(m);
  }
});

/* ===== Global controls ===== */
document.getElementById('playAgain').addEventListener('click', ()=>{
  g1.reset(); g2.reset(); hideWin();
  startCountdown(); // fresh countdown for rematch
});

/* ===== Intro overlay (instructions) ===== */
const intro = document.getElementById('overlay');
document.getElementById('intro-play').addEventListener('click', ()=>{
  intro.style.display='none';
  startCountdown();
});
document.getElementById('intro-close').addEventListener('click', ()=>{
  intro.style.display='none';
  startCountdown();
});

/* ===== Countdown ===== */
const countdown = document.getElementById('countdown');
const countNum = document.getElementById('countNum');

function startCountdown(){
  matchLocked = true;
  // reset boards so both start fair if the user closed/opened overlays oddly
  g1.reset(); g2.reset();
  g1.setEnabled(false); g2.setEnabled(false);

  let seq = ['3','2','1','GO!'];
  let i=0;
  countNum.textContent = seq[i];
  countdown.style.display='flex';

  const tick = () => {
    i++;
    if(i<seq.length){
      countNum.textContent = seq[i];
      countNum.parentElement.style.animation='none';
      // re-trigger pop animation
      void countNum.offsetWidth;
      countNum.parentElement.style.animation='pop 240ms ease-out';
      setTimeout(tick, i===seq.length-1 ? 650 : 650);
    }else{
      // end
      countdown.style.display='none';
      matchLocked = false;
      g1.setEnabled(true); g2.setEnabled(true);
    }
  };
  setTimeout(tick, 650);
}

/* ===== Win overlay ===== */
const winLayer=document.getElementById('win-layer');
const winTitle=document.getElementById('win-title');

function announceWinner(label){
  matchLocked = true; // stop further input
  winTitle.textContent = (label==='P1' ? 'Player 1 wins! üéâ' : 'Player 2 wins! üéâ');
  winLayer.style.display='flex';
}
function hideWin(){ winLayer.style.display='none'; matchLocked=false; g1.setEnabled(true); g2.setEnabled(true); }

document.getElementById('win-again').addEventListener('click', ()=>{ hideWin(); startCountdown(); });
document.getElementById('win-close').addEventListener('click', hideWin);
</script>
</body>
</html>
